"""
Vector Store Module

Manages ChromaDB vector store operations including:
- Creating and loading collections
- Adding documents with embeddings
- Similarity search
"""
import os
import chromadb
from typing import List, Optional
from langchain_core.documents import Document
from langchain_google_genai import GoogleGenerativeAIEmbeddings
from langchain_chroma import Chroma


class VectorStoreManager:
    """
    Manages ChromaDB vector store for document embeddings.
    
    Provides methods for adding documents, searching, and managing collections.
    """
    
    def __init__(
        self,
        persist_directory: str,
        collection_name: str = "documents",
        embedding_model: str = "models/gemini-embedding-001",
        google_api_key: Optional[str] = None
    ):
        """
        Initialize the vector store manager.
        
        Args:
            persist_directory: Directory to persist ChromaDB data
            collection_name: Name of the collection
            embedding_model: Google embedding model to use
            google_api_key: Google API key (uses env if not provided)
        """
        self.persist_directory = persist_directory
        self.collection_name = collection_name
        
        # Ensure persistence directory exists
        os.makedirs(persist_directory, exist_ok=True)
        
        # Initialize embeddings
        self.embeddings = GoogleGenerativeAIEmbeddings(
            model=embedding_model,
            google_api_key=google_api_key
        )
        
        # Initialize or load vector store
        self._vector_store: Optional[Chroma] = None
    
    @property
    def vector_store(self) -> Chroma:
        """Get or create the vector store instance."""
        if self._vector_store is None:
            self._vector_store = Chroma(
                collection_name=self.collection_name,
                embedding_function=self.embeddings,
                persist_directory=self.persist_directory
            )
        return self._vector_store
    
    def add_documents(self, documents: List[Document]) -> List[str]:
        """
        Add documents to the vector store with deduplication.
        
        Checks if document with same ID exists:
        - If exists and ID matches but hash differs: Update (Upsert)
        - If exists and hash matches: Skip
        - If new: Add
        
        Args:
            documents: List of documents to add
            
        Returns:
            List of document IDs added or updated
        """
        if not documents:
            print("No documents provided to add.")
            return []
        
        # Extract IDs from metadata (generated by doc processor)
        # Fallback to None if not present (should ideally be there)
        ids_to_add = [doc.metadata.get("id") for doc in documents]
        print(ids_to_add)
        
        # If any doc is missing an ID, we might fallback to default UUID generation
        # But for our logic we expect IDs.
        if any(id is None for id in ids_to_add):
            # Fallback to standard add if no robust IDs
            print("Warning: Some documents missing 'id' metadata. Skipping deduplication logic.")
            return self.vector_store.add_documents(documents)
            
        # Check existing docs
        existing_docs = self.vector_store.get(ids=ids_to_add, include=["metadatas"])
        existing_ids = set(existing_docs["ids"])
        print(existing_ids)
        
        # Map existing ID to its metadata
        id_to_metadata = {
            id: meta 
            for id, meta in zip(existing_docs["ids"], existing_docs["metadatas"]) 
            if meta
        }
        print(id_to_metadata)
        docs_to_upsert = []
        ids_to_upsert = []
        
        skipped_count = 0
        
        for doc, doc_id in zip(documents, ids_to_add):
            print(doc_id)
            if doc_id in existing_ids:
                # Check hash
                existing_hash = id_to_metadata.get(doc_id, {}).get("hash")
                new_hash = doc.metadata.get("hash")
                
                if existing_hash and new_hash and existing_hash == new_hash:
                    # Exact match, skip
                    skipped_count += 1
                    continue
            
            # If not exists, or exists but hash mismatch -> Upsert
            docs_to_upsert.append(doc)
            ids_to_upsert.append(doc_id)
            
        if docs_to_upsert:
            print("Adding/Updating documents...", docs_to_upsert)
            self.vector_store.add_documents(docs_to_upsert, ids=ids_to_upsert)
            print(f"Ingestion: Added/Updated {len(docs_to_upsert)} documents. Skipped {skipped_count} unchanged.")
            return ids_to_upsert
        else:
            print(f"Ingestion: All {skipped_count} documents were unchanged. Skipped.")
            return []
    
    def similarity_search(
        self, 
        query: str, 
        k: int = 4,
        filter: Optional[dict] = None
    ) -> List[Document]:
        """
        Search for similar documents.
        
        Args:
            query: Search query
            k: Number of results to return
            filter: Optional metadata filter
            
        Returns:
            List of similar documents
        """
        return self.vector_store.similarity_search(
            query=query,
            k=k,
            filter=filter
        )
    
    def similarity_search_with_score(
        self, 
        query: str, 
        k: int = 4
    ) -> List[tuple]:
        """
        Search for similar documents with relevance scores.
        
        Args:
            query: Search query
            k: Number of results to return
            
        Returns:
            List of (document, score) tuples
        """
        return self.vector_store.similarity_search_with_score(query=query, k=k)
    
    def delete_collection(self) -> None:
        """Delete the entire collection."""
        self.vector_store.delete_collection()
        self._vector_store = None
    
    def get_collection_stats(self) -> dict:
        """
        Get statistics about the collection.
        
        Returns:
            Dictionary with collection statistics
        """
        collection = self.vector_store._collection
        return {
            "name": self.collection_name,
            "count": collection.count(),
            "persist_directory": self.persist_directory
        }
    
    def as_retriever(self, search_kwargs: Optional[dict] = None):
        """
        Get a retriever interface for the vector store.
        
        Args:
            search_kwargs: Optional search configuration
            
        Returns:
            Retriever instance
        """
        search_kwargs = search_kwargs or {"k": 4}
        return self.vector_store.as_retriever(search_kwargs=search_kwargs)
